PROBLEMS

* Rebasing can't be transformed from 32-bit to 64-bit. Possible solutions:
  - Make 64-bit application not relocatable -- NOT POSSIBLE
  - Write custom loader -- OK
  - Extend relocated fields -- EH
  - Write loader that sits on top of dyld?

* Disable PIE -- it is a flag in Mach-O header. All virtual addresses then correspond to runtime
                 addresses.



But still have to account for dynamic linking...
But it eliminates the need for rebasing. Woot woot! Can remove rebase during conversion.
This will only work on PIE code, however.

Hmm. But dynamic libraries must be position-independent. Back to square 1.

Try using ABS32 instead of pointer.

-----------------

- Need to transform bindings.
- Need to transform rebasings.

PROBLEM: How to know which address space any given address corresponds to?
WORKAROUND: There seem to be 4 different address spaces:
            - System dylibs
            - User dylibs & code
            - Heap
            - Stack
In the beginning, the 32- to 64-bit translator determines the prefixes of these and the range of the lower 32 bits.
The advantages of this approach are the following:
 - We can let dyld modify pointers directly.


1. Convert executables to dylibs.

- Write segfault handler.
- Patch dyld to handle bindings with abs32.


Will need to handle stack pushes/pops.

06/12/2020
NEW INTERMEDIATE GOAL: Write program that uses Mach-O library to insert arbitrary instructions
into Mach-O text segment.

-------

Problems with inserting instructions.

The patching/rebasing problem arises from the fact that not all of the Mach-O binary is fully parsed. In its fully parsed state, it wouldn't involve ANY offsets, only pointers to structures that will contain the offsets at build time.

Patching instructions -> Construct a linked list of instruction wrappers.
                         The instruction wrappers include the instruction bytes and length and
                         the type of patching (rip-relative jump, rip-relative memory access).

Patching rebase info  -> Decode rebase opcode stream into array of triples
                         (as described in <mach-o/loader.h>). Re-encode at build time to determine
                         length. Re-encode at emit time to emit.

Patching bind info    -> Same as rebase info.

