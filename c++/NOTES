Keep in file format -- don't parse
Instead, construct a map of offset dependencies.

Data structures:
- Map of offset dependencies: file offset -> "pointers"
- Index of all offsets (as pointers)

Tasks:
Inserting a load command:
          (1) Find all offset records above expanded address; add to them.
          (2) For all pairs in map, adjust pointers. If the first and second of the pair lie on the same


Inserting an instruction:
          Same as inserting an


nah, just update everything every time!



The first step involves only modifications in-place, so references and pointers remain valid.
The second step involves inserting raw bytes into the binary, but this occurs at the top level so no reference or pointer invalidation occurs.


----

Pass 2 of parsing -- can't entirely be done in one pass.


---

Data in code -- how to represent? Or just ignore at this point?
Hmm... parsing instructions causes difficulties.

How to address? Parsing queue?

Perhaps prioritize some commands over others. E.g. prioritize LC_DATA_IN_CODE, LC_FUNCTION_STARTS, LC_MAIN, etc. over LC_SEGMENTs.

Dependency Graph
(x <- y) means that x depends on y

LC_MAIN <- LC_SEGMENT
LC_SEGMENT <- LC_DATA_IN_CODE
LC_FUNCTION_STARTS <- LC_SEGMENT


----

Pass 1: Construct multimap of load command IDs to offsets.
Pass 2:

----

Halo's binary doesn't use LC_DATA_IN_CODE, yet does have data in code. So proceed with guessing
which instructions are correct and skipping invalid ones (treating them as data blobs).

---

Idea -- don't even record rebase/bind information separately; record the information inside the section blobs themselves.
 - Advantage: easy to regenerate at emit time without bookkeeping during editing.
 - Disadvantage: Can't print out rebase information easily.

-------

Transforming Ideas

Two stages.
Stage 1: transform each MachO node into other node of opposite bits. Add each node do (void *) map.
Stage 2: bind all memebrs of MachO nodes using map.

-----


ParseEnv, 2nd pass?
Each section checks for resolution requests within its address range. If one matches, then remap that area.
-------

Create a scripting langauge.
Keywords: vmaddr, offset, offset, insert, read, write


------

Getting all addresses within a restricted range.

- Write a mmap() wrapper that adds a fixed mask.
- Write a mmap()


-------

STACK:     can memory-map new region and point $rsp to it.
HEAP:      interposer.
MMAP, ETC: interposer.
SYSLIBS:   OK as long as they're in the non-lazy symbols section?
USRLIBS:   OK

-- or, for the time being --
use segfault-driven method.

Next goal: translate 32-bit instructions to 64-bit equivalents
e.g.
push abs32 -> lea r11, [rip + off32] \ push r11
jmp dword ptr



2 PROJECTS:
Write program that given 64-bit executable, is able to get all addresses in given address range.

DONE

-------

Relocation entry:
 - jmp <disp32> -- X86_64_RELOC_BRANCH
 - call <disp32> -- X86_64_RELOC_BRANCH
 - dq <abs64> -- X86_64_RELOC_UNSIGNED

Initial values indicate offsets within the symbol.

Store relocation info with corresponding section blob, then collect at Build.

--------


for each node, need to emit info.
give information about each edge
then descend into edges

-----

call 0
pop eax

->

lea eax, [rip + <patch-diff>]

----

Decouple 'call 0 \ pop eax' issue with 32-bit-to-64-bit transformation.
Add initial pass for macho-tool that converts such trickery into the equivalent rebase opcodes.
